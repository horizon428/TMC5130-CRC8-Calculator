using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;

[TestClass]
public class CRC8Tests
{
    // 实际通信数据测试用例
    private static readonly (byte[] Data, byte Expected)[] RealCommunicationTestVectors = new[]
    {
        // 读取寄存器命令
        (new byte[] { 0x05, 0x00, 0x02 }, (byte)0x8F),  // 读取寄存器 0x02
        (new byte[] { 0x05, 0x00, 0x6F }, (byte)0x84),  // 读取寄存器 0x6F

        // 寄存器读取响应
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xB7 }, (byte)0xC1),  // 寄存器0x02响应
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xB8 }, (byte)0x1F),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xB9 }, (byte)0x96),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xBA }, (byte)0xD8),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xBB }, (byte)0x51),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xBC }, (byte)0xFF),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xBD }, (byte)0x76),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xBE }, (byte)0x38),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xBF }, (byte)0xB1),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xC0 }, (byte)0x45),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xC1 }, (byte)0xCC),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xC2 }, (byte)0x82),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xC3 }, (byte)0x0B),
        (new byte[] { 0x05, 0xFF, 0x02, 0x00, 0x00, 0x00, 0xC4 }, (byte)0xA5),
        (new byte[] { 0x05, 0xFF, 0x6F, 0x80, 0x0A, 0x00, 0xDB }, (byte)0xFB),  // 寄存器0x6F响应

        // 写入寄存器命令
        (new byte[] { 0x05, 0x00, 0x80, 0x00, 0x00, 0x00, 0x04 }, (byte)0xA9),  // 写入寄存器0x00
        (new byte[] { 0x05, 0x00, 0x93, 0x00, 0x00, 0x01, 0xF4 }, (byte)0x74),  // 写入寄存器0x13
        (new byte[] { 0x05, 0x00, 0xF0, 0x00, 0x04, 0x01, 0xC8 }, (byte)0x97),  // 写入寄存器0x70
        (new byte[] { 0x05, 0x00, 0xAA, 0x00, 0x00, 0x03, 0xE8 }, (byte)0xB4),  // 写入寄存器0x2A
        (new byte[] { 0x05, 0x00, 0xAB, 0x00, 0x00, 0xC3, 0x50 }, (byte)0x4F),  // 写入寄存器0x2B
        (new byte[] { 0x05, 0x00, 0xA8, 0x00, 0x00, 0x01, 0xF4 }, (byte)0x8F),  // 写入寄存器0x28
        (new byte[] { 0x05, 0x00, 0xA4, 0x00, 0x03, 0x0D, 0x40 }, (byte)0x6E),  // 写入寄存器0x24
        (new byte[] { 0x05, 0x00, 0xA9, 0x00, 0x00, 0x02, 0xBC }, (byte)0x8B),  // 写入寄存器0x29
        (new byte[] { 0x05, 0x00, 0xAC, 0x00, 0x00, 0x05, 0x78 }, (byte)0xD2),  // 写入寄存器0x2C
        (new byte[] { 0x05, 0x00, 0xA7, 0x00, 0x00, 0x00, 0x0A }, (byte)0x4A),  // 写入寄存器0x27
        (new byte[] { 0x05, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00 }, (byte)0xC6),  // 写入寄存器0x20
        (new byte[] { 0x05, 0x00, 0xA4, 0x00, 0x00, 0x00, 0x00 }, (byte)0xA2),  // 写入寄存器0x24
        (new byte[] { 0x05, 0x00, 0xAD, 0x00, 0x00, 0x00, 0x00 }, (byte)0x07)   // 写入寄存器0x2D
    };

    [TestMethod]
    public void TestRealCommunicationData()
    {
        foreach (var testVector in RealCommunicationTestVectors)
        {
            // 测试CalculateCRCValue方法
            byte result = CRC8Calculator.CalculateCRCValue(testVector.Data);
            Assert.AreEqual(testVector.Expected, result,
                $"CRC calculation failed for data: {BitConverter.ToString(testVector.Data)}, " +
                $"Expected: {testVector.Expected:X2}, Got: {result:X2}");

            // 测试CalculateCRC方法
            byte[] dataWithCRC = new byte[testVector.Data.Length + 1];
            Array.Copy(testVector.Data, dataWithCRC, testVector.Data.Length);
            CRC8Calculator.CalculateCRC(dataWithCRC, dataWithCRC.Length);
            Assert.AreEqual(testVector.Expected, dataWithCRC[dataWithCRC.Length - 1],
                $"CalculateCRC method failed for data: {BitConverter.ToString(testVector.Data)}");
        }
    }

    [TestMethod]
    public void TestConsistency()
    {
        // 使用实际通信数据测试两个方法的一致性
        foreach (var testVector in RealCommunicationTestVectors)
        {
            // 使用CalculateCRCValue计算
            byte expectedCRC = CRC8Calculator.CalculateCRCValue(testVector.Data);
            
            // 使用CalculateCRC计算
            byte[] dataWithCRC = new byte[testVector.Data.Length + 1];
            Array.Copy(testVector.Data, dataWithCRC, testVector.Data.Length);
            CRC8Calculator.CalculateCRC(dataWithCRC, dataWithCRC.Length);
            
            Assert.AreEqual(expectedCRC, dataWithCRC[dataWithCRC.Length - 1],
                $"CRC calculation methods produced different results for data: {BitConverter.ToString(testVector.Data)}");
        }
    }
}
